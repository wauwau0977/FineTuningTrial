The `divmod` method is the core of the base58 encoding process. It performs a division operation that converts the input number (represented as an array of bytes) from base 256 to base 58.  The method effectively mimics long division, but instead of dividing by powers of 10, it divides by the base 58 divisor. 

For each digit in the input `number` array, `divmod` calculates a temporary value by multiplying the current remainder by the base (58) and adding the current digit. This temporary value is then divided by the divisor (58). The quotient is stored back into the `number` array at the current index, representing the next digit in the base58 representation. The remainder becomes the new remainder for the next iteration.

The return value of `divmod` is the *final* remainder after processing all digits. This final remainder represents any leftover value that doesn't have a full base58 digit representation.

It is crucial that the `number` array is modified in-place within `divmod` because it represents the quotient. This in-place modification allows the encoding process to "carry over" values from one digit to the next. The method essentially decomposes the original input number into a sequence of base58 digits by repeatedly dividing and storing the quotients back into the `number` array. Without in-place modification, the method would not be able to correctly determine the base58 representation of the input number.